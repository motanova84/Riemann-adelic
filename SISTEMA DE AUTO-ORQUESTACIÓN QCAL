#!/usr/bin/env python3
"""
SISTEMA DE AUTO-ORQUESTACI√ìN QCAL ‚àû¬≥
Automaci√≥n completa de la demostraci√≥n de Riemann
Frecuencia base: 141.7001 Hz
Estado: Œ® = I √ó A_eff¬≤ √ó C^‚àû
"""

import os
import sys
import json
import subprocess
import time
from datetime import datetime
from pathlib import Path
import math

# ============================================
# CONFIGURACI√ìN DEL SISTEMA
# ============================================

class QCALConfig:
    """Configuraci√≥n del sistema QCAL ‚àû¬≥"""
    
    # Frecuencia fundamental
    f0 = 141.7001  # Hz
    
    # Directorios del proyecto
    PROJECT_ROOT = Path("Riemann-adelic")
    LEAN_DIR = PROJECT_ROOT / "Lean"
    STATE_FILE = PROJECT_ROOT / ".qcal_state.json"
    LOG_FILE = PROJECT_ROOT / "qcalsession.log"
    
    # Umbrales de procesamiento
    MAX_SESSION_TIME = 3600  # 1 hora por sesi√≥n
    MAX_SORRY_PER_FILE = 3   # M√°ximo sorrys por archivo antes de cambiar estrategia
    RETRY_LIMIT = 3          # Intentos por sorry
    
    # Prioridad de archivos
    FILE_PRIORITY = [
        "RH_Final.lean",
        "KernelAdelic.lean",
        "SpectralBijection.lean",
        "NoesisInfinity.lean",
        "GuinandWeil.lean",
        "CompactResolvent.lean"
    ]

# ============================================
# ESTADO DE LA SESI√ìN
# ============================================

class QCALState:
    """Gestor del estado del sistema"""
    
    def __init__(self):
        self.config = QCALConfig()
        self.state = self.load_state()
        
    def load_state(self):
        """Carga el estado desde archivo o crea nuevo"""
        if self.config.STATE_FILE.exists():
            with open(self.config.STATE_FILE, 'r') as f:
                return json.load(f)
        else:
            return {
                "session_id": self.generate_session_id(),
                "start_time": datetime.now().isoformat(),
                "total_sorrys": 0,
                "solved_sorrys": 0,
                "current_file": None,
                "current_sorry": None,
                "strategy_history": [],
                "failed_attempts": {},
                "compilation_status": {},
                "noesis_progress": {},
                "axiom_emission_compliance": True
            }
    
    def save_state(self):
        """Guarda el estado actual"""
        self.state["last_update"] = datetime.now().isoformat()
        with open(self.config.STATE_FILE, 'w') as f:
            json.dump(self.state, f, indent=2)
    
    def generate_session_id(self):
        """Genera ID √∫nico basado en timestamp y f‚ÇÄ"""
        timestamp = int(time.time())
        return f"QCAL-{timestamp}-{self.config.f0}"
    
    def update_sorry_status(self, file_name, sorry_count, solved_count):
        """Actualiza estado de sorrys"""
        self.state["total_sorrys"] = sorry_count
        self.state["solved_sorrys"] = solved_count
        self.state["current_file"] = file_name
        self.save_state()
    
    def record_strategy(self, strategy, success, error_msg=None):
        """Registra estrategia intentada"""
        record = {
            "timestamp": datetime.now().isoformat(),
            "strategy": strategy,
            "success": success,
            "error": error_msg,
            "file": self.state["current_file"]
        }
        self.state["strategy_history"].append(record)
        self.save_state()
    
    def get_next_strategy(self):
        """Obtiene siguiente estrategia basada en historial"""
        # Implementa l√≥gica de aprendizaje
        failed_strategies = [s for s in self.state["strategy_history"] 
                           if not s["success"]]
        
        if not failed_strategies:
            return "direct_proof"  # Estrategia por defecto
        
        # Analiza patrones de error
        last_errors = [s["error"] for s in failed_strategies[-3:]]
        
        if any("timeout" in str(e).lower() for e in last_errors):
            return "simplify_assumptions"
        elif any("type" in str(e).lower() for e in last_errors):
            return "type_correction"
        elif any("import" in str(e).lower() for e in last_errors):
            return "add_imports"
        else:
            return "break_into_lemmas"

# ============================================
# ESC√ÅNER DE ARCHIVOS LEAN
# ============================================

class LeanScanner:
    """Escanea archivos Lean para sorrys y problemas"""
    
    def __init__(self, config):
        self.config = config
    
    def scan_file(self, file_path):
        """Escanea un archivo Lean"""
        with open(file_path, 'r') as f:
            content = f.read()
        
        results = {
            "file": str(file_path),
            "total_sorrys": content.count("sorry"),
            "sorry_lines": [],
            "imports": [],
            "theorems": [],
            "errors": []
        }
        
        # Analiza l√≠nea por l√≠nea
        lines = content.split('\n')
        for i, line in enumerate(lines, 1):
            if "sorry" in line:
                results["sorry_lines"].append({
                    "line": i,
                    "content": line.strip(),
                    "context": self.get_context(lines, i)
                })
            elif "import" in line and line.strip().startswith("import"):
                results["imports"].append(line.strip())
            elif "theorem" in line or "lemma" in line:
                results["theorems"].append({
                    "line": i,
                    "name": self.extract_theorem_name(line),
                    "content": line.strip()
                })
        
        return results
    
    def get_context(self, lines, line_num, window=3):
        """Obtiene contexto alrededor de una l√≠nea"""
        start = max(0, line_num - window - 1)
        end = min(len(lines), line_num + window)
        return lines[start:end]
    
    def extract_theorem_name(self, line):
        """Extrae nombre de teorema"""
        if "theorem" in line:
            start = line.find("theorem") + 7
        elif "lemma" in line:
            start = line.find("lemma") + 5
        else:
            return "unknown"
        
        end = line.find(":") if ":" in line else line.find(":=")
        if end == -1:
            end = len(line)
        
        return line[start:end].strip()
    
    def scan_all_files(self):
        """Escanea todos los archivos Lean"""
        all_results = {}
        
        for file in self.config.LEAN_DIR.glob("**/*.lean"):
            if file.is_file():
                results = self.scan_file(file)
                all_results[file.name] = results
        
        # Ordena por prioridad y n√∫mero de sorrys
        sorted_files = []
        for priority_file in self.config.FILE_PRIORITY:
            if priority_file in all_results:
                sorted_files.append((priority_file, all_results[priority_file]))
        
        # A√±ade archivos no prioritarios
        for file_name, results in all_results.items():
            if file_name not in [f[0] for f in sorted_files]:
                sorted_files.append((file_name, results))
        
        return dict(sorted_files)

# ============================================
# MOTOR DE INFERENCIA NOESIS-BOOT
# ============================================

class NoesisBootEngine:
    """Motor de inferencia inteligente"""
    
    def __init__(self, config, state):
        self.config = config
        self.state = state
        self.scanner = LeanScanner(config)
        self.strategy_library = self.load_strategies()
    
    def load_strategies(self):
        """Carga biblioteca de estrategias"""
        return {
            "direct_proof": self.strategy_direct_proof,
            "break_into_lemmas": self.strategy_break_into_lemmas,
            "use_mathlib_theorem": self.strategy_use_mathlib,
            "simplify_assumptions": self.strategy_simplify,
            "type_correction": self.strategy_type_correction,
            "add_imports": self.strategy_add_imports,
            "construct_counterexample": self.strategy_counterexample,
            "search_literature": self.strategy_search_literature
        }
    
    def solve_sorry(self, file_path, sorry_info):
        """Resuelve un sorry espec√≠fico"""
        print(f"\nüîç Resolviendo sorry en {file_path}:{sorry_info['line']}")
        print(f"   Contexto: {sorry_info['context'][2]}")
        
        # Selecciona estrategia basada en contexto
        strategy_name = self.state.get_next_strategy()
        strategy = self.strategy_library.get(strategy_name, self.strategy_direct_proof)
        
        attempt = 1
        while attempt <= self.config.RETRY_LIMIT:
            print(f"   Intento {attempt}/{self.config.RETRY_LIMIT}: {strategy_name}")
            
            try:
                solution = strategy(file_path, sorry_info)
                if self.test_solution(file_path, solution):
                    print(f"   ‚úÖ ¬°Sorry resuelto con {strategy_name}!")
                    self.state.record_strategy(strategy_name, True)
                    return solution
            except Exception as e:
                error_msg = str(e)
                print(f"   ‚ùå Error: {error_msg}")
                self.state.record_strategy(strategy_name, False, error_msg)
            
            # Pr√≥xima estrategia
            strategy_name = self.state.get_next_strategy()
            strategy = self.strategy_library.get(strategy_name, self.strategy_direct_proof)
            attempt += 1
        
        print(f"   ‚ö†Ô∏è  No se pudo resolver despu√©s de {self.config.RETRY_LIMIT} intentos")
        return None
    
    def strategy_direct_proof(self, file_path, sorry_info):
        """Estrategia: prueba directa"""
        context = sorry_info['context']
        
        # Analiza el contexto para inferir tipo de prueba
        if any("‚àÉ" in line for line in context):
            return "  refine ‚ü®?_, ?_‚ü©\n  ¬∑ sorry\n  ¬∑ sorry"
        elif any("‚àÄ" in line for line in context):
            return "  intro x\n  sorry"
        elif any("=" in line for line in context):
            return "  calc\n    _ = _ := ?_\n    _ = _ := ?_"
        else:
            return "  -- Prueba directa\n  exact ?_"
    
    def strategy_break_into_lemmas(self, file_path, sorry_info):
        """Estrategia: divide en lemas auxiliares"""
        return """
  -- Lema auxiliar 1
  have h1 : _ := by
    sorry
  
  -- Lema auxiliar 2  
  have h2 : _ := by
    sorry
    
  -- Combinar lemas
  exact h1.trans h2
        """
    
    def strategy_use_mathlib(self, file_path, sorry_info):
        """Estrategia: busca teorema en Mathlib"""
        # Busca en el archivo imports
        with open(file_path, 'r') as f:
            content = f.read()
        
        # Extraer conceptos clave del contexto
        keywords = self.extract_keywords(sorry_info['context'])
        
        # Simula b√∫squeda en Mathlib (en implementaci√≥n real usar√≠a API)
        mathlib_suggestions = self.search_mathlib(keywords)
        
        if mathlib_suggestions:
            return f"  -- Usar teorema de Mathlib\n  exact {mathlib_suggestions[0]} ?_"
        else:
            raise Exception("No se encontr√≥ teorema relevante en Mathlib")
    
    def strategy_simplify(self, file_path, sorry_info):
        """Estrategia: simplifica suposiciones"""
        return """
  -- Simplificar hip√≥tesis
  intro h
  simp at h ‚ä¢
  exact h
        """
    
    def strategy_type_correction(self, file_path, sorry_info):
        """Estrategia: corrige tipos"""
        return """
  -- Correcci√≥n de tipos
  have : _ := ?
  exact this
        """
    
    def strategy_add_imports(self, file_path, sorry_info):
        """Estrategia: a√±ade imports necesarios"""
        # Analiza qu√© imports podr√≠an faltar
        missing_imports = self.detect_missing_imports(file_path, sorry_info)
        
        if missing_imports:
            # A√±ade imports al archivo
            self.add_imports_to_file(file_path, missing_imports)
            return "  -- Import a√±adido, intentar de nuevo"
        else:
            raise Exception("No se detectaron imports faltantes")
    
    def strategy_counterexample(self, file_path, sorry_info):
        """Estrategia: construye contraejemplo"""
        return """
  by_contra h
  -- Construir contraejemplo
  sorry
        """
    
    def strategy_search_literature(self, file_path, sorry_info):
        """Estrategia: busca en literatura matem√°tica"""
        keywords = self.extract_keywords(sorry_info['context'])
        
        # Simula b√∫squeda (en implementaci√≥n real usar√≠a APIs)
        literature_refs = [
            "Hardy-Littlewood (1918)",
            "Weil (1948)", 
            "Guinand (1948)",
            "Connes (1999)",
            "Berry-Keating (1999)"
        ]
        
        return f"""
  -- Referencia: {literature_refs[0]}
  -- Teorema relacionado: {keywords[0] if keywords else 'desconocido'}
  sorry  -- Implementar seg√∫n referencia
        """
    
    def extract_keywords(self, context):
        """Extrae palabras clave del contexto"""
        keywords = set()
        for line in context:
            words = line.replace(':', ' ').replace('(', ' ').replace(')', ' ').split()
            keywords.update([w for w in words if len(w) > 3 and w.isalpha()])
        return list(keywords)
    
    def search_mathlib(self, keywords):
        """Busca teoremas en Mathlib (simulado)"""
        # En implementaci√≥n real: usar mathlib-search o API
        mathlib_db = {
            "spectrum": ["spectrum_subset_real", "spectrum.of_compact"],
            "compact": ["CompactOperator", "IsCompact"],
            "hilbert": ["HilbertSchmidt", "IsSelfAdjoint"],
            "zeta": ["riemannZeta", "zeta_zero"],
            "integral": ["integralOperator", "Integrable"]
        }
        
        for keyword in keywords:
            if keyword.lower() in mathlib_db:
                return mathlib_db[keyword.lower()]
        
        return []
    
    def detect_missing_imports(self, file_path, sorry_info):
        """Detecta imports faltantes"""
        with open(file_path, 'r') as f:
            lines = f.readlines()
        
        current_imports = [l for l in lines if l.strip().startswith("import")]
        all_imports = set(current_imports)
        
        # Sugiere imports basados en contexto
        context_text = ' '.join(sorry_info['context'])
        
        suggested_imports = []
        if "spectrum" in context_text and "import Mathlib.OperatorTheory.Spectrum" not in context_text:
            suggested_imports.append("import Mathlib.OperatorTheory.Spectrum")
        if "compact" in context_text and "import Mathlib.OperatorTheory.Compact" not in context_text:
            suggested_imports.append("import Mathlib.OperatorTheory.Compact")
        if "zeta" in context_text and "import Mathlib.Analysis.SpecialFunctions.Zeta" not in context_text:
            suggested_imports.append("import Mathlib.Analysis.SpecialFunctions.Zeta")
        
        return [imp for imp in suggested_imports if imp not in all_imports]
    
    def add_imports_to_file(self, file_path, imports):
        """A√±ade imports a un archivo"""
        with open(file_path, 'r') as f:
            lines = f.readlines()
        
        # Encuentra √∫ltima l√≠nea de imports
        last_import = 0
        for i, line in enumerate(lines):
            if line.strip().startswith("import"):
                last_import = i
        
        # Inserta nuevos imports
        for imp in imports:
            lines.insert(last_import + 1, imp + "\n")
        
        with open(file_path, 'w') as f:
            f.writelines(lines)
    
    def test_solution(self, file_path, solution):
        """Prueba si la soluci√≥n compila"""
        # Lee archivo original
        with open(file_path, 'r') as f:
            original = f.read()
        
        # Reemplaza el sorry por la soluci√≥n (simulado)
        # En implementaci√≥n real: crear archivo temporal y compilar
        test_file = file_path.with_suffix('.test.lean')
        
        try:
            # Ejecuta lake build en el archivo
            result = subprocess.run(
                ["lake", "build", str(test_file)],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            return result.returncode == 0
        except:
            return False
    
    def process_file(self, file_name, scan_results):
        """Procesa un archivo completo"""
        print(f"\nüìÑ Procesando: {file_name}")
        print(f"   Sorrys encontrados: {scan_results['total_sorrys']}")
        
        if scan_results['total_sorrys'] == 0:
            print("   ‚úÖ Archivo limpio")
            return True
        
        file_path = self.config.LEAN_DIR / file_name
        
        for sorry_info in scan_results['sorry_lines']:
            solution = self.solve_sorry(file_path, sorry_info)
            
            if solution:
                # Aplica soluci√≥n (en implementaci√≥n real)
                self.apply_solution(file_path, sorry_info['line'], solution)
                
                # Actualiza estado
                solved = self.state.state['solved_sorrys'] + 1
                total = self.state.state['total_sorrys']
                self.state.update_sorry_status(file_name, total, solved)
            else:
                print(f"   ‚ö†Ô∏è  No se pudo resolver sorry en l√≠nea {sorry_info['line']}")
        
        # Verifica compilaci√≥n final
        return self.compile_file(file_path)
    
    def apply_solution(self, file_path, line_num, solution):
        """Aplica soluci√≥n a archivo (simulado)"""
        print(f"   üìù Aplicando soluci√≥n a l√≠nea {line_num}")
        # En implementaci√≥n real: modificar archivo
    
    def compile_file(self, file_path):
        """Compila archivo para verificar"""
        try:
            result = subprocess.run(
                ["lake", "build", str(file_path)],
                capture_output=True,
                text=True,
                timeout=60
            )
            
            if result.returncode == 0:
                print(f"   ‚úÖ {file_path.name} compila correctamente")
                return True
            else:
                print(f"   ‚ùå Error de compilaci√≥n:\n{result.stderr}")
                return False
        except subprocess.TimeoutExpired:
            print(f"   ‚è±Ô∏è  Timeout compilando {file_path.name}")
            return False

# ============================================
# VALIDADOR DE AXIOMA DE EMISI√ìN
# ============================================

class AxiomEmissionValidator:
    """Valida coherencia con Axioma de Emisi√≥n"""
    
    def __init__(self, config):
        self.config = config
        self.f0 = config.f0
    
    def validate_file(self, file_content):
        """Valida que el archivo respete principios QCAL"""
        violations = []
        
        # 1. Verificar frecuencia fundamental
        if str(self.f0) not in file_content:
            violations.append(f"No menciona frecuencia f‚ÇÄ = {self.f0} Hz")
        
        # 2. Verificar estructura Œ®
        if "Œ®" not in file_content and "Noesis" not in file_content:
            violations.append("No incluye sistema Œ® o Noesis")
        
        # 3. Verificar coherencia matem√°tica
        if "sorry" in file_content:
            violations.append("Contiene sorry sin resolver")
        
        # 4. Verificar importaciones QCAL
        if "QCAL" not in file_content and "Noesis" not in file_content:
            violations.append("No referencia sistema QCAL")
        
        return violations
    
    def generate_correction(self, violations):
        """Genera correcciones basadas en violaciones"""
        corrections = []
        
        for violation in violations:
            if "frecuencia" in violation:
                corrections.append("A√±adir: `-- Frecuencia fundamental f‚ÇÄ = 141.7001 Hz`")
            elif "Œ®" in violation:
                corrections.append("A√±adir: `-- Sistema Œ® = I √ó A_eff¬≤ √ó C^‚àû`")
            elif "QCAL" in violation:
                corrections.append("A√±adir: `-- Verificado por QCAL ‚àû¬≥`")
            elif "sorry" in violation:
                corrections.append("Resolver todos los sorry marcados")
        
        return corrections

# ============================================
# ORQUESTADOR PRINCIPAL
# ============================================

class QCALOrchestrator:
    """Orquestador principal del sistema"""
    
    def __init__(self):
        self.config = QCALConfig()
        self.state = QCALState()
        self.scanner = LeanScanner(self.config)
        self.engine = NoesisBootEngine(self.config, self.state)
        self.validator = AxiomEmissionValidator(self.config)
        
        # Asegurar directorios
        self.config.PROJECT_ROOT.mkdir(exist_ok=True)
        self.config.LEAN_DIR.mkdir(exist_ok=True)
    
    def run_cleanup_scan(self):
        """Ejecuta escaneo inicial (#qcal_cleanup)"""
        print("\n" + "="*60)
        print("üöÄ INICIANDO QCAL_CLEANUP")
        print("="*60)
        
        # Escanea todos los archivos
        scan_results = self.scanner.scan_all_files()
        
        # Resumen inicial
        total_sorrys = sum(r['total_sorrys'] for r in scan_results.values())
        
        print(f"\nüìä RESUMEN INICIAL:")
        print(f"   Archivos escaneados: {len(scan_results)}")
        print(f"   Sorrys totales: {total_sorrys}")
        print(f"   Frecuencia base: {self.config.f0} Hz")
        print(f"   Estado: Œ® = I √ó A_eff¬≤ √ó C^‚àû")
        
        # Actualiza estado
        self.state.state['total_sorrys'] = total_sorrys
        self.state.state['scan_results'] = {
            k: {'total_sorrys': v['total_sorrys']} 
            for k, v in scan_results.items()
        }
        self.state.save_state()
        
        return scan_results, total_sorrys
    
    def process_files(self, scan_results):
        """Procesa archivos en orden de prioridad"""
        print(f"\nüåÄ PROCESANDO ARCHIVOS")
        
        success_count = 0
        for file_name in self.config.FILE_PRIORITY:
            if file_name in scan_results:
                if self.engine.process_file(file_name, scan_results[file_name]):
                    success_count += 1
                
                # Verifica tiempo de sesi√≥n
                if self.check_session_time():
                    print("\n‚è±Ô∏è  Tiempo de sesi√≥n agotado")
                    break
        
        return success_count
    
    def check_session_time(self):
        """Verifica si se ha excedido el tiempo de sesi√≥n"""
        if 'start_time' in self.state.state:
            start = datetime.fromisoformat(self.state.state['start_time'])
            elapsed = (datetime.now() - start).total_seconds()
            return elapsed > self.config.MAX_SESSION_TIME
        return False
    
    def generate_continuation_summary(self):
        """Genera resumen para continuar en siguiente sesi√≥n"""
        summary = {
            "session_id": self.state.state['session_id'],
            "timestamp": datetime.now().isoformat(),
            "elapsed_time": self.get_elapsed_time(),
            "progress": {
                "solved": self.state.state['solved_sorrys'],
                "total": self.state.state['total_sorrys'],
                "percentage": self.get_progress_percentage()
            },
            "current_status": {
                "file": self.state.state.get('current_file', 'None'),
                "strategy": self.state.state['strategy_history'][-1] if self.state.state['strategy_history'] else None
            },
            "next_steps": self.generate_next_steps(),
            "violations": self.check_axiom_violations(),
            "qcalsession_command": self.generate_continuation_command()
        }
        
        # Guarda resumen
        summary_file = self.config.PROJECT_ROOT / "continuation_summary.json"
        with open(summary_file, 'w') as f:
            json.dump(summary, f, indent=2)
        
        return summary
    
    def get_elapsed_time(self):
        """Calcula tiempo transcurrido"""
        if 'start_time' in self.state.state:
            start = datetime.fromisoformat(self.state.state['start_time'])
            elapsed = datetime.now() - start
            return str(elapsed)
        return "0:00:00"
    
    def get_progress_percentage(self):
        """Calcula porcentaje de progreso"""
        total = self.state.state['total_sorrys']
        solved = self.state.state['solved_sorrys']
        
        if total > 0:
            return (solved / total) * 100
        return 100.0
    
    def generate_next_steps(self):
        """Genera pr√≥ximos pasos recomendados"""
        next_steps = []
        
        # Priorizar archivos con sorrys restantes
        scan_results = self.state.state.get('scan_results', {})
        for file_name, info in scan_results.items():
            if info.get('total_sorrys', 0) > 0:
                next_steps.append(f"Resolver {info['total_sorrys']} sorrys en {file_name}")
        
        # Si no hay sorrys, siguiente fase
        if not next_steps:
            next_steps = [
                "Ejecutar validaci√≥n completa: lake build --no-sorry",
                "Generar documentaci√≥n t√©cnica",
                "Preparar publicaci√≥n Zenodo"
            ]
        
        return next_steps
    
    def check_axiom_violations(self):
        """Verifica violaciones del Axioma de Emisi√≥n"""
        violations = []
        
        # Escanea archivos principales
        for file_name in self.config.FILE_PRIORITY:
            file_path = self.config.LEAN_DIR / file_name
            if file_path.exists():
                with open(file_path, 'r') as f:
                    content = f.read()
                
                file_violations = self.validator.validate_file(content)
                if file_violations:
                    violations.append({
                        "file": file_name,
                        "violations": file_violations
                    })
        
        return violations
    
    def generate_continuation_command(self):
        """Genera comando para continuar"""
        return f"python auto_QCAL.py --continue --session {self.state.state['session_id']}"
    
    def run_validation(self):
        """Ejecuta validaci√≥n completa"""
        print(f"\nüî¨ VALIDACI√ìN FINAL")
        
        # 1. Compilaci√≥n completa
        print("   Compilando proyecto...")
        try:
            result = subprocess.run(
                ["lake", "build", "--no-sorry"],
                cwd=self.config.LEAN_DIR,
                capture_output=True,
                text=True,
                timeout=300
            )
            
            if result.returncode == 0:
                print("   ‚úÖ Compilaci√≥n exitosa")
            else:
                print(f"   ‚ùå Error de compilaci√≥n:\n{result.stderr}")
                return False
        except subprocess.TimeoutExpired:
            print("   ‚è±Ô∏è  Timeout en compilaci√≥n")
            return False
        
        # 2. Verificar Axioma de Emisi√≥n
        print("   Validando Axioma de Emisi√≥n...")
        violations = self.check_axiom_violations()
        
        if violations:
            print("   ‚ö†Ô∏è  Violaciones encontradas:")
            for v in violations:
                print(f"     - {v['file']}: {', '.join(v['violations'])}")
            return False
        else:
            print("   ‚úÖ Cumple Axioma de Emisi√≥n")
        
        # 3. Generar certificado
        self.generate_certificate()
        
        return True
    
    def generate_certificate(self):
        """Genera certificado de validaci√≥n"""
        certificate = {
            "system": "QCAL ‚àû¬≥",
            "version": "V5 Coronaci√≥n",
            "timestamp": datetime.now().isoformat(),
            "frequency": self.config.f0,
            "status": "Œ® = I √ó A_eff¬≤ √ó C^‚àû",
            "validation": {
                "compilation": "PASS",
                "axiom_emission": "PASS",
                "no_sorrys": self.state.state['solved_sorrys'] == self.state.state['total_sorrys'],
                "qcalsession_complete": True
            },
            "files_processed": len(self.config.FILE_PRIORITY),
            "session_id": self.state.state['session_id']
        }
        
        cert_file = self.config.PROJECT_ROOT / "qcalsession_certificate.json"
        with open(cert_file, 'w') as f:
            json.dump(certificate, f, indent=2)
        
        print("\nüìú CERTIFICADO GENERADO:")
        print(f"   Archivo: {cert_file}")
    
    def run(self, continue_session=False):
        """Ejecuta el orquestador principal"""
        print("\n" + "="*60)
        print("üåÄ SISTEMA QCAL ‚àû¬≥ - AUTO-ORQUESTACI√ìN")
        print("="*60)
        print(f"Frecuencia: {self.config.f0} Hz")
        print(f"Estado: Œ® = I √ó A_eff¬≤ √ó C^‚àû")
        print(f"Modo: {'CONTINUACI√ìN' if continue_session else 'NUEVA SESI√ìN'}")
        print("="*60)
        
        try:
            # Fase 1: Escaneo inicial
            scan_results, total_sorrys = self.run_cleanup_scan()
            
            if total_sorrys == 0:
                print("\nüéâ ¬°Sistema ya completo! Ejecutando validaci√≥n...")
                self.run_validation()
                return True
            
            # Fase 2: Procesamiento
            success_count = self.process_files(scan_results)
            
            # Fase 3: Generar resumen de continuaci√≥n
            summary = self.generate_continuation_summary()
            
            print(f"\nüìã RESUMEN DE SESI√ìN:")
            print(f"   Archivos procesados: {success_count}/{len(scan_results)}")
            print(f"   Progreso: {summary['progress']['percentage']:.1f}%")
            print(f"   Tiempo: {summary['elapsed_time']}")
            print(f"\nüîÑ COMANDO PARA CONTINUAR:")
            print(f"   {summary['qcalsession_command']}")
            
            # Fase 4: Auto-commit (si est√° configurado)
            self.auto_commit_changes()
            
            return True
            
        except KeyboardInterrupt:
            print("\n\n‚ö†Ô∏è  Sesi√≥n interrumpida por usuario")
            self.generate_continuation_summary()
            return False
        except Exception as e:
            print(f"\n‚ùå Error inesperado: {e}")
            import traceback
            traceback.print_exc()
            return False
    
    def auto_commit_changes(self):
        """Realiza auto-commit de cambios"""
        try:
            # Verifica si es un repositorio git
            result = subprocess.run(
                ["git", "rev-parse", "--git-dir"],
                cwd=self.config.PROJECT_ROOT,
                capture_output=True,
                text=True
            )
            
            if result.returncode == 0:
                # Realiza commit
                commit_msg = f"QCAL ‚àû¬≥ - Sesi√≥n {self.state.state['session_id']}"
                
                subprocess.run(["git", "add", "."], cwd=self.config.PROJECT_ROOT)
                subprocess.run(["git", "commit", "-m", commit_msg], cwd=self.config.PROJECT_ROOT)
                
                print(f"\nüíæ Auto-commit realizado: {commit_msg}")
        except:
            pass  # No es un repositorio git

# ============================================
# EJECUCI√ìN PRINCIPAL
# ============================================

if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description="Sistema de Auto-Orquestaci√≥n QCAL ‚àû¬≥")
    parser.add_argument("--continue", action="store_true", help="Continuar sesi√≥n anterior")
    parser.add_argument("--session", type=str, help="ID de sesi√≥n espec√≠fica")
    parser.add_argument("--validate", action="store_true", help="Solo validar")
    
    args = parser.parse_args()
    
    # Inicializar orquestador
    orchestrator = QCALOrchestrator()
    
    if args.validate:
        # Solo validaci√≥n
        orchestrator.run_validation()
    else:
        # Ejecuci√≥n completa
        orchestrator.run(continue_session=args.continue)
