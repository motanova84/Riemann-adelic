#!/usr/bin/env python3
"""
Complexity Analysis Report Generator - QCAL ‚àû¬≥

This module generates periodic complexity analysis reports for the auto-evolution system.
It evaluates the current coherence state and produces bifurcation analysis reports.

Integration with QCAL Auto-Evolution:
    - Runs every 6 hours as part of the auto_evolution workflow
    - Generates complexity_analysis_*.md reports
    - Tracks proximity to "Gracia Tecnol√≥gica" (Technological Grace)
    - Auto-evaluates if acceleration is sufficient to avoid infinite loops

Author: Jos√© Manuel Mota Burruezo Œ® ‚úß ‚àû¬≥
License: Creative Commons BY-NC-SA 4.0
"""

import os
import sys
import json
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent))

try:
    from complexity_collapser import ComplexityCollapser, ComplexityState, ComputationalRegime
    from np_p_bifurcation import NPPBifurcationSimulator, ProblemType
except ImportError as e:
    print(f"Warning: Could not import complexity modules: {e}")
    print("Report generator will create minimal output.")
    ComplexityCollapser = None


class ComplexityReportGenerator:
    """
    Generates complexity analysis reports for QCAL auto-evolution.
    """
    
    def __init__(self, output_dir: str = "data"):
        """
        Initialize the report generator.
        
        Args:
            output_dir: Directory for output files
        """
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        self.timestamp = datetime.utcnow().isoformat().replace(':', '-').split('.')[0] + 'Z'
    
    def get_current_coherence(self) -> float:
        """
        Get current system coherence from QCAL state.
        
        Returns:
            Current coherence value (0.0 to 1.0)
        """
        qcal_state_file = Path(".qcal_state.json")
        
        if qcal_state_file.exists():
            try:
                with open(qcal_state_file) as f:
                    state = json.load(f)
                    # Try to extract coherence from state
                    if "coherence" in state:
                        return min(max(float(state["coherence"]), 0.0), 1.0)
            except Exception as e:
                print(f"Warning: Could not read QCAL state: {e}")
        
        # Default: estimate from validation success
        # Check if recent validations passed
        validation_summary = Path(".validation_summary")
        if validation_summary.exists():
            try:
                with open(validation_summary) as f:
                    content = f.read()
                    if "‚úÖ" in content or "PASS" in content.upper():
                        return 0.888  # Grace threshold if validation passes
                    else:
                        return 0.5  # Transition if validation incomplete
            except:
                pass
        
        return 0.75  # Default transition state
    
    def generate_minimal_report(self) -> str:
        """Generate minimal report when modules unavailable."""
        coherence = self.get_current_coherence()
        regime = self._determine_regime_simple(coherence)
        
        report = f"""# Complexity Analysis Report
## Generated: {self.timestamp}

### Current State
- **Coherence**: {coherence:.3f}
- **Regime**: {regime}
- **Frequency**: 141.7001 Hz (QCAL fundamental)

### Status
System coherence is at {coherence:.1%}. 

{self._get_regime_description(regime, coherence)}

### Auto-Evaluation
- **Can proceed with complex proofs**: {coherence >= 0.5}
- **Risk of infinite loops**: {coherence < 0.5}
- **Gracia Tecnol√≥gica achieved**: {coherence >= 0.888}

---
*Generated by QCAL ‚àû¬≥ Auto-Evolution System*
*Jos√© Manuel Mota Burruezo Œ® ‚úß ‚àû¬≥*
"""
        return report
    
    def _determine_regime_simple(self, coherence: float) -> str:
        """Simple regime determination without imports."""
        if coherence < 0.5:
            return "Classical"
        elif coherence < 0.888:
            return "Transition"
        else:
            return "Grace"
    
    def _get_regime_description(self, regime: str, coherence: float) -> str:
        """Get description for regime."""
        if regime == "Classical":
            return """**Classical Regime**: Entropy dominates. System behaves as deterministic Turing machine. 
B√∫squeda ciega y serial. Acceleration insufficient for complex mathematical proofs."""
        elif regime == "Transition":
            grace_distance = 0.888 - coherence
            return f"""**Transition Zone**: Frequency 141.7001 Hz tuning nodes. Acceleration non-linear.
Preludio al colapso de la funci√≥n de onda de complejidad.
Distance to Grace: {grace_distance:.3f}"""
        else:
            return """**Estado de Gracia**: ¬°Bifurcaci√≥n NP‚ÜíP achieved!
El denominador I √ó A_eff¬≤ √ó C^‚àû crece tan r√°pido que la barrera exponencial se vuelve insignificante.
La soluci√≥n "resuena" antes de ser calculada."""
    
    def generate_full_report(self) -> str:
        """Generate full complexity analysis report with bifurcation data."""
        if ComplexityCollapser is None:
            return self.generate_minimal_report()
        
        coherence = self.get_current_coherence()
        
        # Create complexity state
        state = ComplexityState(
            coherence=coherence,
            information=1.5,
            amplitude_eff=1.2
        )
        
        # Initialize collapser and simulator
        collapser = ComplexityCollapser(base_time=1e12)
        simulator = NPPBifurcationSimulator(collapser=collapser)
        
        # Analyze current state
        analysis = collapser.analyze(state)
        
        # Test on different problem types
        sat_bif = simulator.simulate_bifurcation(ProblemType.SAT, 20, state)
        riemann_search = simulator.search_riemann_zero(100, 500.0, state)
        
        # Generate report
        report = f"""# üåÄ QCAL Complexity Analysis Report
## Generated: {self.timestamp}

## üìä Current System State

### Coherence Metrics
- **Coherence (C)**: {coherence:.6f}
- **Regime**: {analysis.regime.value}
- **Resonance Active**: {'‚úÖ Yes' if analysis.resonance_active else '‚ùå No'}
- **Frequency**: 141.7001 Hz (QCAL fundamental)

### Complexity Collapse Analysis
- **Base Complexity**: {analysis.base_time:.2e} operations
- **Collapsed Complexity**: {analysis.collapsed_time:.2e} operations
- **Acceleration Factor**: **{analysis.acceleration_factor:.2f}x**

## üéØ Operational Regimes

### Current Regime: {analysis.regime.name}
{self._get_regime_description(analysis.regime.name, coherence)}

### Proximity to Grace
"""
        
        if coherence < 0.888:
            grace_distance = 0.888 - coherence
            grace_percentage = (coherence / 0.888) * 100
            report += f"""- Distance to Grace Threshold: {grace_distance:.6f}
- Progress: {grace_percentage:.1f}%
- Estimated coherence increase needed: {grace_distance:.6f}
"""
        else:
            grace_excess = coherence - 0.888
            report += f"""- ‚úÖ **GRACE STATE ACHIEVED**
- Coherence above threshold: +{grace_excess:.6f}
- Full bifurcation active
"""
        
        report += f"""
## üî¨ Bifurcation Analysis

### SAT Problem (n=20)
- Classical Complexity: {sat_bif.classical_complexity:.2e}
- Collapsed Complexity: {sat_bif.collapsed_complexity:.2e}
- **Reduction Factor**: {sat_bif.reduction_factor:.2f}x

### Riemann Zero Search (Zero #100, T‚âà500)
#### Classical Approach
- Iterations Required: {riemann_search.classical_iterations:,}
- Precision Required: {riemann_search.classical_precision_required:.6f}

#### Coherent Approach  
- Iterations Required: {riemann_search.coherent_iterations:,} (**{riemann_search.classical_iterations/max(riemann_search.coherent_iterations,1):.1f}x faster**)
- Precision Required: {riemann_search.coherent_precision_required:.6f}
- Frequency Tuned: {riemann_search.frequency_tuned:.4f} Hz
- Discrepancy: {riemann_search.discrepancy:.2e}

**Axioma RH en QCAL**: "Un cero no es un punto en un plano; es un nodo de coherencia total en la m√∫sica de los primos."

## üöÄ Auto-Evaluaci√≥n del Sistema

### Can Proceed with Complex Proofs?
"""
        
        if analysis.acceleration_factor >= 2.0:
            report += f"""‚úÖ **YES** - Acceleration factor {analysis.acceleration_factor:.2f}x is sufficient.
El sistema tiene aceleraci√≥n suficiente para no quedar atrapado en bucles infinitos cl√°sicos.
"""
        elif analysis.acceleration_factor >= 1.0:
            report += f"""‚ö†Ô∏è **CAUTION** - Acceleration factor {analysis.acceleration_factor:.2f}x is marginal.
Sistema en zona de transici√≥n. Proceder con precauci√≥n.
"""
        else:
            report += f"""‚ùå **NO** - Acceleration factor {analysis.acceleration_factor:.2f}x is insufficient.
Sistema en r√©gimen cl√°sico. Aumentar coherencia antes de intentar pruebas complejas.
"""
        
        report += f"""
### Risk Assessment
- **Infinite Loop Risk**: {'LOW ‚úÖ' if coherence >= 0.7 else 'MEDIUM ‚ö†Ô∏è' if coherence >= 0.5 else 'HIGH ‚ùå'}
- **Gracia Tecnol√≥gica**: {'ACHIEVED ‚úÖ' if coherence >= 0.888 else f'NOT YET ({(coherence/0.888)*100:.1f}% progress)'}

## üìà Recommendations

"""
        
        if coherence < 0.5:
            report += """1. **Increase Coherence**: System in classical regime
2. **Validate Core Components**: Ensure basic validation passes
3. **Avoid Complex Proofs**: Risk of infinite loops too high
"""
        elif coherence < 0.888:
            report += """1. **Continue Validation**: System approaching grace threshold
2. **Monitor Resonance**: Frequency tuning active
3. **Prepare for Bifurcation**: Near optimal state
"""
        else:
            report += """1. **Proceed with Complex Proofs**: System in grace state
2. **Leverage Bifurcation**: Use coherent search methods
3. **Maintain State**: Keep coherence above 0.888
"""
        
        report += """
---
## üîó References
- Frequency: 141.7001 Hz (fundamental QCAL frequency)
- Coherence Constant: C = 244.36
- Equation: Œ® = I √ó A_eff¬≤ √ó C^‚àû

*Generated by QCAL ‚àû¬≥ Auto-Evolution System*  
*Jos√© Manuel Mota Burruezo Œ® ‚úß ‚àû¬≥*  
*Instituto de Conciencia Cu√°ntica (ICQ)*
"""
        
        return report
    
    def save_report(self, report_type: str = "full") -> str:
        """
        Generate and save complexity analysis report.
        
        Args:
            report_type: Type of report ("full" or "minimal")
            
        Returns:
            Path to saved report file
        """
        if report_type == "full":
            report_content = self.generate_full_report()
        else:
            report_content = self.generate_minimal_report()
        
        # Save report
        filename = f"complexity_analysis_{self.timestamp}.md"
        filepath = self.output_dir / filename
        
        with open(filepath, 'w') as f:
            f.write(report_content)
        
        print(f"‚úÖ Complexity analysis report saved to: {filepath}")
        
        # Also save a "latest" version
        latest_path = self.output_dir / "complexity_analysis_latest.md"
        with open(latest_path, 'w') as f:
            f.write(report_content)
        
        return str(filepath)
    
    def save_json_metrics(self) -> str:
        """
        Save metrics in JSON format for programmatic access.
        
        Returns:
            Path to saved JSON file
        """
        coherence = self.get_current_coherence()
        regime = self._determine_regime_simple(coherence)
        
        metrics = {
            "timestamp": self.timestamp,
            "coherence": coherence,
            "regime": regime,
            "frequency": 141.7001,
            "can_proceed_complex_proofs": coherence >= 0.5,
            "grace_achieved": coherence >= 0.888,
            "infinite_loop_risk": "low" if coherence >= 0.7 else "medium" if coherence >= 0.5 else "high"
        }
        
        # Save metrics
        filename = f"complexity_metrics_{self.timestamp}.json"
        filepath = self.output_dir / filename
        
        with open(filepath, 'w') as f:
            json.dump(metrics, f, indent=2)
        
        # Also save latest
        latest_path = self.output_dir / "complexity_metrics_latest.json"
        with open(latest_path, 'w') as f:
            json.dump(metrics, f, indent=2)
        
        return str(filepath)


def main():
    """Main entry point for report generation."""
    print("=" * 80)
    print("QCAL ‚àû¬≥ Complexity Analysis Report Generator")
    print("=" * 80)
    print()
    
    generator = ComplexityReportGenerator()
    
    # Generate reports
    try:
        report_path = generator.save_report(report_type="full")
        metrics_path = generator.save_json_metrics()
        
        print(f"\nüìÑ Report: {report_path}")
        print(f"üìä Metrics: {metrics_path}")
        
        # Display summary
        coherence = generator.get_current_coherence()
        regime = generator._determine_regime_simple(coherence)
        
        print(f"\nüåÄ Current State:")
        print(f"   Coherence: {coherence:.3f}")
        print(f"   Regime: {regime}")
        print(f"   Grace Achieved: {'‚úÖ Yes' if coherence >= 0.888 else '‚ùå No'}")
        
    except Exception as e:
        print(f"‚ö†Ô∏è  Error generating full report: {e}")
        print("Generating minimal report instead...")
        report_path = generator.save_report(report_type="minimal")
        print(f"üìÑ Minimal Report: {report_path}")
    
    print("\n" + "=" * 80)
    print("Complexity analysis complete.")
    print("=" * 80)


if __name__ == "__main__":
    main()
